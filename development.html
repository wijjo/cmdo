<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>

<meta http-equiv="content-type" content="text/html;charset=utf-8" />

<title>Cmdo help development</title>

<style type="text/css">
* {
    font-size: 12pt;
}

.h1bar {
    background-color: #aaaaff;
    margin-top: 32px;
    margin-bottom: 12px;
    padding: 4px;
    width: 100%;
    height: auto;
    border-spacing: 0;
    border-collapse: collapse;
}

.h1barheading {
    font-size: 16pt;
    font-weight: bold;
    margin-top: 0px;
    margin-bottom: 0px;
    margin-left: 0px;
    margin-right: 0px;
    padding: 4px;
}

.h1bartopcell {
    text-align: right;
}

.h1bartoplink {
    font-size: 11pt;
    text-indent: 1em;
    padding: 2px;
}

.h2bar {
    background-color: #e8e8ff;
    margin-top: 32px;
    margin-bottom: 12px;
    padding: 2px;
    width: 100%;
    height: auto;
    border-spacing: 0;
    border-collapse: collapse;
}

.h2barheading {
    font-size: 14pt;
    font-weight: bold;
    margin-top: 0px;
    margin-bottom: 0px;
    margin-left: 0px;
    margin-right: 0px;
    padding: 2px;
}

.h2bartopcell {
    text-align: right;
}

.h2bartoplink {
    font-size: 11pt;
    text-indent: 1em;
    padding: 2px;
}

.heading1 {
    background-color: #aaaaff;
    font-size: 16pt;
    font-weight: bold;
    margin-top: 32px;
    margin-bottom: 12px;
    margin-left: 0px;
    margin-right: 0px;
    padding: 4px;
}

.heading2 {
    background-color: #e8e8ff;
    font-size: 14pt;
    font-weight: bold;
    margin-top: 32px;
    margin-bottom: 12px;
    margin-left: 0px;
    margin-right: 0px;
    padding: 2px;
}

.heading3 {
    border-bottom: 1px solid gray;
    width: auto;
    font-size: 13pt;
    font-weight: bold;
    margin-top: 24px;
    margin-bottom: 12px;
    margin-left: 0px;
    margin-right: 0px;
    padding: 0;
}

.heading4 {
    font-size: 12pt;
    font-weight: bold;
    margin-top: 12px;
    margin-bottom: 6px;
    margin-left: 0px;
    margin-right: 0px;
    padding: 0;
}

.heading5 {
    font-size: 12pt;
    font-weight: italic;
    margin-top: 8px;
    margin-bottom: 4px;
    margin-left: 0px;
    margin-right: 0px;
    padding: 0;
}

.heading6 {
    font-size: 11pt;
    font-weight: italic;
    margin-top: 8px;
    margin-bottom: 4px;
    margin-left: 0px;
    margin-right: 0px;
    padding: 0;
}

.gentable {
    border: 1px solid gray;
    margin-bottom: 8px;
    border-spacing: 0;
    border-collapse: collapse;
}

.genheader {
    border: 1px solid gray;
    background-color: #F2F2FF;
    padding: 2px 4px;
}

.genrow {
}

.gencell {
    border: 1px solid gray;
    padding: 2px 4px;
}

ol {
    margin-top: 0px;
    margin-bottom: 0px;
    margin-left: -8px;
    margin-right: 0px;
}

ol li {
    list-style-type: decimal;
}

ul li {
}

p {
    margin-top: 4px;
    margin-bottom: 4px;
    margin-left: 0px;
    margin-right: 0px;
    padding: 0;
}

pre {
    background-color: #eeeeee;
    font-size: 10pt;
}

.tocblock {
    border: 1px solid gray;
    background-color: #eeeeff;
    padding: 10px;
    margin: 20px;
}

.toc0 {
}

.toc1 {
    padding-top: 10px;
    font-weight: bold;
}

.toc2 {
    padding-left: 16px;
}

.toc3 {
    padding-left: 32px;
}

.toc4 {
    padding-left: 48px;
}

.block {
    padding-top: 6px;
    padding-bottom: 6px;
}
</style>

<style type="text/css" media="print">
.h1bartoplink {
    display: none;
}

.h2bartoplink {
    display: none;
}

.tocblock {
    display: none;
}

</style>

</head>

<body>

<h1 class="heading1">Cmdo Developer Guide</h1>
  <div id="toc" class="tocblock">
    <div class="toc1"><a href=#tocitem1>Introduction</a></div>
    <div class="toc1"><a href=#tocitem2>Application Structure</a></div>
      <div class="toc2"><a href=#tocitem3>Executable</a></div>
      <div class="toc2"><a href=#tocitem4>Modules</a></div>
    <div class="toc1"><a href=#tocitem5>Tutorial - Building an Application</a></div>
      <div class="toc2"><a href=#tocitem6>The Main Executable</a></div>
      <div class="toc2"><a href=#tocitem7>Adding Functions</a></div>
      <div class="toc2"><a href=#tocitem8>Decorating Functions</a></div>
    <div class="toc1"><a href=#tocitem9>Adding Documentation</a></div>
      <div class="toc2"><a href=#tocitem10>Structured Text Syntax</a></div>
      <div class="toc2"><a href=#tocitem11>Adding a Documentation Module</a></div>
  </div>
  <span id="tocitem1">
  <table class="h2bar"><tr><td><h2 class="h2barheading">Introduction</h2></td><td class="h2bartopcell"><a href="#toc" class="h2bartoplink">Top</a></td></tr></table>
    <div class="block">
    This guide is a work in progress. Until completed, the best resource remains
    the source code of working applications, including "ardo", a part of this
    distribution.
    </div>
  </span>
  <span id="tocitem2">
  <table class="h2bar"><tr><td><h2 class="h2barheading">Application Structure</h2></td><td class="h2bartopcell"><a href="#toc" class="h2bartoplink">Top</a></td></tr></table>
    <span id="tocitem3">
    <h3 class="heading3">Executable</h3>
      <div class="block">
      Cmdo applications start with a single tiny Python script. The contents of
      this script will be almost identical for most applications, with the
      exception of the version number passed to cmdo.main(). The script name
      determines both the application's internal name and which directories get
      searched for modules and configuration files. An easy way to get started
      is to copy "/usr/bin/cmdo" (adjust for you local installation), and then
      rename and edit the copy to specify your application's version number.
      </div>
    </span>
    <span id="tocitem4">
    <h3 class="heading3">Modules</h3>
      <div class="block">
      Cmdo applications are structured as a set of Python modules identified by
      special extensions and placed in one or more well-known directories.
      Modules with appropriate extensions are loaded (only) as needed to fulfill
      function calls or documentation requests. Unlike native Python, you never
      have to explicitly import anything. All discovered modules will be loaded
      whenever they are needed.
      </div>
      <div class="block">
      The following command displays the module search path for Cmdo.
      </div>
<pre>
cmdo 'print CMDO.program.dirsScript'</pre>

      <div class="block">
      The included Ardo sample application provides another example. These two
      commands displays its search path and the additional path for core Cmdo
      modules, e.g. for the "help" and "version" functions.
      </div>
<pre>
ardo 'print CMDO.program.dirsScript'
ardo 'print CMDO.engine.dirsScript'</pre>

      <h4 class="heading4">".cmdo" Modules</h4>
        <div class="block">
        Modules with the ".cmdo" extension supply Python code to implement both
        external and internal functions (and classes). Decorators (discussed
        later) declare functions that are externally accessible, i.e. from the
        command line.
        </div>
        <div class="block">
        Module syntax is pure Python. No pre-processing occurs. The only thing
        special about code modules is how they are discovered and automatically
        loaded, and the two special namespaces that are injected as global
        symbols. The two namespaces are "CMDO" and a similar capitalized version
        of the application name. They behave like pre-imported modules. Their
        contents are discussed later.
        </div>
        <div class="block">
        Exported functions are prefixed by the module's base name, e.g.
        functions in the "weather.cmdo" module are prefixed by "weather.".
        </div>
      <h4 class="heading4">".cmdocore" Modules</h4>
        <div class="block">
        Core code modules are similar to ".cmdo" modules in providing Python
        code for internal and external functions. They differ in two ways.
        Exported functions are not prefixed by a module namespace and the
        modules are pre-loaded, rather than loaded on demand.
        </div>
      <h4 class="heading4">".cmdodoc" Modules</h4>
        <div class="block">
        These modules supply raw "structured text" for help documentation. The
        resources are accessed by module base name and formatted by a chosen
        "publisher" or by the default text publisher. E.g. "tutorial.cmdodoc"
        can produce documentation for "myapp" using the command "myapp help
        tutorial". The "format=" keyword option can select the "html", "xml",
        "text" (default), or other publisher. The "view=yes" keyword
        option/value causes it to load in the viewer or browser registered by
        mime type.
        </div>
        <div class="block">
        Syntax is identical for all documentation, whether placed in a
        ".cmdodoc" module or in doc strings inside a code module. It is similar
        to the formats used by wiki collaborative text web sites. It supports
        headings, lists, tables, plain text, macros, and arbitrary Python code.
        Structured text syntax is described more fully in a later section.
        </div>
    </span>
  </span>
  <span id="tocitem5">
  <table class="h2bar"><tr><td><h2 class="h2barheading">Tutorial - Building an Application</h2></td><td class="h2bartopcell"><a href="#toc" class="h2bartoplink">Top</a></td></tr></table>
    <div class="block">
    The following sections build a sample application called "Todo" that, as you
    may surmise, manages a to-do list from the command line.
    </div>
    <span id="tocitem6">
    <h3 class="heading3">The Main Executable</h3>
      <div class="block">
      All a main program has to do is import and call "cmdo.main()", and supply
      a version number argument. Version number strings can be arbitrary or
      meaningful. It merely becomes the return value from the version()
      function. Here's what the "todo" script might look like if you want the
      "todo version" command to display "todo 0.1".
      </div>
<pre>
#!/usr/bin/env python
from cmdo import main
if __name__ == '__main__':
    main('0.1')</pre>

      <div class="block">
      Create this script, make it executable, and place it somewhere in the
      system path, e.g./usr/local/bin/todo. Run it and verify that you see a
      basic help screen. Note that the first time you run it the directory
      "~/.todo" gets created. Try "todo version" and check the version number.
      It reports version numbers for both the application and the engine.
      </div>
    </span>
    <span id="tocitem7">
    <h3 class="heading3">Adding Functions</h3>
      <div class="block">
      The only functions we have at this point are "help" and "version". So now
      we want to add real to-do list functionality to a new module. The
      following command displays the available module directories.
      </div>
<pre>
todo 'print CMDO.program.dirsScript'</pre>

      <div class="block">
      Functions can either reside in ".cmdo" or ".cmdocore" modules, depending
      on whether or not you wish to use the module name as a prefix and whether
      or not you want them pre-loaded. For our example we'll write 3 functions
      to work with to-do list items. We expect to add more later, e.g. to
      display a fancy calendar.
      </div>
      <div class="block">
      It makes sense to name the module designated to work with the to-do item
      list "list.cmdo". It will supply the "list.add", "list.remove" and
      "list.show" functions. Later we might add a "calendar.cmdo" module and
      others.
      </div>
      <div class="block">
      Create and edit a new file, "~/.todo/todo.d/list.cmdo", or for a more
      permanent/shared location, "/usr/local/lib/todo/todo.d/list.cmdo". You
      probably have to first create the directory, for example:
      </div>
<pre>
mkdir -p /usr/local/lib/todo/todo.d</pre>

      <div class="block">
      Of course, depending on location, you may need root privileges, so the
      following may work better (example user is "john").
      </div>
<pre>
sudo mkdir -p /usr/local/lib/todo/todo.d
sudo chown -R john /usr/local/lib/todo</pre>

      <div class="block">
      This document won't explain many of the implementation details, but notice
      how it's all ordinary Python code.
      </div>
      <div class="block">
      The first line tricks editors into showing Python syntax highlighting.
      </div>
<pre>
#!/usr/bin/env python</pre>

      <div class="block">
      Then we establish the data file path and set up the global variable to
      hold an item list in memory.
      </div>
<pre>
import os.path
path  = os.path.expanduser('~/.todo/list')
items = None</pre>

      <div class="block">
      The first utility function, getItems(), loads the item list from the file
      if it's not already loaded.
      </div>
<pre>
def getItems():
    global items
    if items is None:
        items = []
        if os.path.exists(path):
            f = open(path)
            for line in open(path):
                fields = line.strip().split(' ', 1)
                items.append((int(fields[0]), fields[1]))
            f.close()
            items.sort(cmp = lambda x, y: cmp(y[0], x[0]))
    return items</pre>

      <div class="block">
      The other needed utility function, saveItems(), saves the item list from
      memory to file.
      </div>
<pre>
def saveItems(items):
    if items is not None:
        f = open(path, 'w')
        for item in items:
            f.write('%d %s\n' % (item[0], item[1]))
        f.close()</pre>

      <div class="block">
      The remaining functions are intended to serve as the to-do list's external
      interface.
      </div>
      <div class="block">
      The add() function adds a task and priority to the item list and saves to
      disk.
      </div>
<pre>
def add(priority, task):
    'Add a prioritized task'
    items = getItems()
    items.append((priority, task))
    saveItems(items)</pre>

      <div class="block">
      The remove() function removes a task by index number and saves to disk.
      </div>
<pre>
def remove(i):
    'Delete a task by index.  Use the show to see index numbers.'
    items = getItems()
    del items[i]
    saveItems(items)</pre>

      <div class="block">
      The show() function displays the sorted list sorted with index numbers.
      </div>
<pre>
def show():
    'Show task list sorted by priority with index numbers.'
    items = getItems()
    items.sort(cmp = lambda x, y: cmp(y[0], x[0]))
    i = 0
    for item in items:
        i += 1
        print '%d) %d %s' % (i, item[0], item[1])</pre>

      <div class="block">
      If this file had a ".py" extension you could import it and use the
      functions without any changes. But you'd still need to implement a command
      line interface, interpret options, validate input, format help screens,
      and invoke functions.
      </div>
      <div class="block">
      Cmdo performs these services automatically once you decorate your
      functions to specify expected argument types. Argument types are generally
      classes that implement a convert() method to take raw input, validate it,
      and return appropriate data.
      </div>
      <div class="block">
      If you run "todo help" you should see the same output you saw before. Your
      new functions are invisible without the decorators. If you want to check
      that the new module loads run this.
      </div>
<pre>
todo -v</pre>

      <div class="block">
      Look through the verbose output for a line similar to this.
      </div>
<pre>
Loading script "/usr/local/lib/todo/todo.d/list.cmdo"...</pre>

    </span>
    <span id="tocitem8">
    <h3 class="heading3">Decorating Functions</h3>
      <div class="block">
      The "@CMDO.export" decorator serves two purposes. It tells the Cmdo engine
      to expose the function externally and supplies type information for
      validating and converting raw input arguments.
      </div>
      <div class="block">
      The decorator accepts zero or more types, which can either be subclasses
      or subclass instances derived from CMDO.TypeBase. In other words, you can
      leave out the parentheses when no type arguments are needed.
      </div>
      <div class="block">
      Basic types like CMDO.Integer, CMDO.String are already defined. Here we
      create two custom types for Priority and list Index by overriding
      CMDO.Integer.
      </div>
      <div class="block">
      The Priority type class uses the "imin" and "imax" keyword arguments to
      limit the acceptable range of integer values. It also specifies a better
      description (through the "desc" keyword argument).
      </div>
      <div class="block">
      The Index type class specifies a minimum value and a description. It also
      overrides convert() to check against the loaded item list and to adjust
      external 1-n values to start at zero internally. "CMDO.ExcBase" exceptions
      (or subclasses) receive special treatment to display a cleaner error
      trace.
      </div>
<pre>
class Priority(CMDO.Integer):
    def __init__(self):
        CMDO.Integer.__init__(self, imin = 1, imax = 5, desc = 'priority')

class Index(CMDO.Integer):
    def __init__(self):
        CMDO.Integer.__init__(self, imin = 1, desc = 'index')
    def convert(self, value):
        i = CMDO.Integer.convert(self, value)
        count = len(getItems())
        if i &gt; count:
            raise CMDO.ExcBase('Bad index, %d (%d to-do item%s)'
                    % (i, count, 's'*(count!=1)))
        return i - 1</pre>

      <div class="block">
      Once custom types are defined we can add "@CMDO.export" decorators to
      inform the engine about exported functions and their expected arguments.
      </div>
      <div class="block">
      The add() function accepts a pair of arguments. The first is our custom
      Priority type. The second is the task string. Note that Priority is just
      the class, because arguments are unnecessary, and CMDO.String is
      instantiated to specify a description (the "desc" keyword argument).
      Insert the "@CMDO.export(..." line above the add function definition.
      </div>
<pre>
@CMDO.export(Priority, CMDO.String(desc = 'task string'))
def add(priority, task):
    ...</pre>

      <div class="block">
      The remove() function accepts an Index argument. Insert the
      "@CMDO.export(..." line above the remove function definition.
      </div>
<pre>
@CMDO.export(Index)
def remove(i):
    ...</pre>

      <div class="block">
      The show() function takes no argument, allowing "@CMDO.export" to appear
      without parentheses. Insert it above the show function definition.
      </div>
<pre>
@CMDO.export
def show():
    ...</pre>

      <div class="block">
      For your convenience, here is the entire "list.cmdo" source.
      </div>
<pre>
#!/usr/bin/env python

import os.path
path  = os.path.expanduser('~/.todo/list')
items = None

class Priority(CMDO.Integer):
    def __init__(self):
        CMDO.Integer.__init__(self, imin = 1, imax = 5, desc = 'priority')

class Index(CMDO.Integer):
    def __init__(self):
        CMDO.Integer.__init__(self, imin = 1, desc = 'index')
    def convert(self, value):
        i = CMDO.Integer.convert(self, value)
        count = len(getItems())
        if i &gt; count:
            raise CMDO.ExcBase('Bad index, %d (%d to-do item%s)'
                    % (i, count, 's'*(count!=1)))
        return i - 1

def getItems():
    global items
    if items is None:
        items = []
        if os.path.exists(path):
            f = open(path)
            for line in open(path):
                fields = line.strip().split(' ', 1)
                items.append((int(fields[0]), fields[1]))
            f.close()
            items.sort(cmp = lambda x, y: cmp(y[0], x[0]))
    return items

def saveItems(items):
    if items is not None:
        f = open(path, 'w')
        for item in items:
            f.write('%d %s\n' % (item[0], item[1]))
        f.close()

@CMDO.export(Priority, CMDO.String(desc = 'task string'))
def add(priority, task):
    'Add a prioritized task'
    items = getItems()
    items.append((priority, task))
    saveItems(items)

@CMDO.export(Index)
def remove(i):
    'Delete a task by index.  Use the show to see index numbers.'
    items = getItems()
    del items[i]
    saveItems(items)

@CMDO.export
def show():
    'Show task list sorted by priority with index numbers.'
    items = getItems()
    items.sort(cmp = lambda x, y: cmp(y[0], x[0]))
    i = 0
    for item in items:
        i += 1
        print '%d) %d %s' % (i, item[0], item[1])</pre>

      <div class="block">
      Now you can run "todo" to see the new functions in the help listing. You
      can also run "todo help list.add" to see help for that function. Notice
      how the Python doc string became the description and how the arguments are
      listed and described.
      </div>
      <div class="block">
      Try this sequence of operations.
      </div>
      <div class="block">
      First add a few tasks.
      </div>
<pre>
todo list.add 3 "Call Phil"
todo list.add 1 "Lunch with Biff"
todo list.add 5 "Pick up Judy"</pre>

      <div class="block">
      Then list them.
      </div>
<pre>
todo list.show</pre>

      <div class="block">
      You see this output.
      </div>
<pre>
1) 5 Pick up Judy
2) 3 Call Phil
3) 1 Lunch with Biff</pre>

      <div class="block">
      Then remove the "Call Phil" task, since you just completed it.
      </div>
<pre>
todo list.remove 2</pre>

      <div class="block">
      Confirm the task is gone.
      </div>
<pre>
todo list.show</pre>

      <div class="block">
      You now see this.
      </div>
<pre>
1) 5 Pick up Judy
2) 1 Lunch with Biff</pre>

      <div class="block">
      Try using bad indexes or priorities to see the error handling.
      </div>
      <div class="block">
      Notice how the key functions are uncluttered by anything by relevant code.
      </div>
    </span>
  </span>
  <span id="tocitem9">
  <table class="h2bar"><tr><td><h2 class="h2barheading">Adding Documentation</h2></td><td class="h2bartopcell"><a href="#toc" class="h2bartoplink">Top</a></td></tr></table>
    <div class="block">
    You saw how function level help gets generated based on doc strings and the
    export decorator arguments. You can also create more general documentation
    that is also available from the command line by using ".cmdodoc" modules.
    </div>
    <div class="block">
    Documentation modules use syntax inspired by wiki technology. Special markup
    that blends well with plain text leaves a document readable in both raw form
    and after transforming to text, HTML, etc. Cmdo supports text, HTML and XML
    formats via the format keyword of the help command. It also supports loading
    in a viewer application by using the mailcap mime type database.
    </div>
    <div class="block">
    The text format called "structured text" is described below.
    </div>
    <span id="tocitem10">
    <h3 class="heading3">Structured Text Syntax</h3>
      <h4 class="heading4">Headings (whole line)</h4>
<pre>
!&lt;text&gt;             Section/heading level 1
!!&lt;text&gt;            Section/heading level 2
!!!&lt;text&gt;           Section/heading level 3
...</pre>

        <div class="block">
        Headings can be continued by lines starting with a "+".
        </div>
      <h4 class="heading4">Lists (whole line)</h4>
<pre>
#&lt;text&gt;             Numbered list level 1
##&lt;text&gt;            Numbered list level 2
###&lt;text&gt;           Numbered list level 3
...
*&lt;text&gt;             Bulleted list level 1
**&lt;text&gt;            Bulleted list level 2
***&lt;text&gt;           Bulleted list level 3
...</pre>

        <div class="block">
        List items can be continued by lines starting with a "+".
        </div>
      <h4 class="heading4">Tables (whole line)</h4>
<pre>
|!...|....|         Header row
|....|....|         Normal cell row</pre>

        <div class="block">
        Table rows can be continued by lines starting with a "+".
        </div>
      <h4 class="heading4">Links (within line)</h4>
<pre>
[[&lt;URL&gt;]]           URL without label
[[Label=&lt;URL&gt;]]     URL with label</pre>

      <h4 class="heading4">Macros (within line):</h4>
<pre>
{{&lt;code&gt;}}          Macro for evaluation</pre>

        <div class="block">
        Macros are good for injecting calculated data or text containing special
        characters. Macros can be any Python expression returning a string. It
        can call functions, reference variables, etc.
        </div>
      <h4 class="heading4">Plain text (multi-line block)</h4>
<pre>
'''
&lt;plain text block&gt;
...
'''</pre>

        <div class="block">
        or
        </div>
<pre>
"""
&lt;plain text block&gt;
...
"""</pre>

        <div class="block">
        Both triple single and double quotes are accepted to allow plain text
        blocks containing one or the other type of quotings, e.g. for Python doc
        strings in sample code. It also makes it easier to use plain text blocks
        inside Python doc strings, e.g. for Cmdo function/module structured text
        documentation.
        </div>
      <h4 class="heading4">Python code (multi-line block)</h4>
<pre>
{{{
&lt;Python code&gt;
...
}}}</pre>

        <div class="block">
        Code blocks are executed, rather than evaluated. It doesn't produce
        text, but can set meta-data, import modules, and create symbols used by
        evaluated macros.
        </div>
        <div class="block">
        For example, to inject a time stamp, combine a code block with one or
        more macros.
        </div>
<pre>
{{{
from time import asctime
}}}
...
The date and time is "{{asctime()}}".</pre>

        <div class="block">
        This will produce something like:
        </div>
<pre>
The date and time is "Mon Apr 30 11:01:03 2007".</pre>

    </span>
    <span id="tocitem11">
    <h3 class="heading3">Adding a Documentation Module</h3>
      <div class="block">
      Place the text listed below in "tutorial.cmdodoc", which you can add to
      the same directory as "list.cmdo". Afterwards run this command for text
      format help...
      </div>
<pre>
todo help tutorial</pre>

      <div class="block">
      ... or this command for HTML output viewed in your browser.
      </div>
<pre>
todo help tutorial format=html view=yes</pre>

      <h4 class="heading4">Tutorial Documentation Module Source</h4>
<pre>
!To-Do Tutorial

!!Prerequisites

|!Name|Description|
|[[Cmdo=http://wijjo.com/cmdo]]|The primary engine|
|[[Python=http://www.python.org]]|The implementation language|

!!Introduction

We will do the following in order to introduce you to your new to-do list
manager.
# Add a few prioritized tasks.
# List tasks by priority.
# Complete a task and remove it.
# List tasks again to confirm removal.

!!Add Tasks
'''
todo list.add 3 "Call Phil"
todo list.add 1 "Lunch with Biff"
todo list.add 5 "Pick up Judy"
'''

!!List Tasks
'''
todo list.show
'''
You should see this output.
'''
1) 5 Pick up Judy
2) 3 Call Phil
3) 1 Lunch with Biff
'''

!!Remove Completed Task
'''
todo list.remove 2
'''
Confirm the task is gone.
'''
todo list.show
'''
You now see this.
'''
1) 5 Pick up Judy
2) 1 Lunch with Biff
'''</pre>

    </span>
  </span>

</body>
</html>
